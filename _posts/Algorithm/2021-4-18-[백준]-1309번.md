---
date: 2021-04-18
title: "[백준]1309번"
categories: 백준
tags: Algorithm
toc: true  
toc_sticky: true
---


# 동물원

문제
---
어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.

| | |
|---|---|
| | |
| | |
| | |
|...|...|

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

입력
---
첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

출력
---
첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

예제 입력1
---
~~~
4
~~~

예제 출력 1
---
~~~
41
~~~

풀이
---
전에 풀었던 RGB문제와 마찬가지로 마지막 우리를 고르는 상황이라고 가정하고 문제를 분석해나갔다.

마지막 줄의 사자우리를 고르는 방법은 

1.왼쪽 우리를 고르는 방법
2.오른쪽 우리를 고르는 방법
3.아무 우리도 고르지 않는 방법

이렇게 세 가지 경우가 있다. 왼쪽 우리를 고르려면 이전 우리가 오른쪽 우리를 골랐거나 아무 우리도 고르지 않았어야 하므로 2번방법 + 3번방법의 경우의 수가 된다.

마찬가지로 오른쪽 우리를 고르려면 이전 우리가 왼쪽 우리를 골랐거나 아무 우리도 고르지 않았어야 하므로 1번방법 + 3번방법의 경우의 수가 된다.

마지막으로 아무 우리도 고르지 않는 방법은 이전 우리가 어떤 우리를 골랐던 관계가 없으므로 1번방법 + 2번방법 + 3번방법의 경우의 수가 된다.

결국 이전 우리의 결과값만 가지고 있으면 본 문제는 쉽게 풀 수가 있는 기초적인 수준의 DP 문제이다. 다만 이전 값이 아니라 전체 DP값을 가지고 있으면 메모리 초과 에러가 났다.


코드
---

import sys

input_function = sys.stdin.readline
# N(1≤N≤100,000)
N = int(input_function())
prev = []

for i in range(N):
    # 왼쪽: [0], 안칠함: [1], 오른쪽: [1]
    curr = [0 for _ in range(3)]
    if i == 0:
        curr[0] = 1
        curr[1] = 1
        curr[2] = 1
    else:
        curr[0] = prev[1] + prev[2]
        curr[1] = prev[0] + prev[1] + prev[2]
        curr[2] = prev[0] + prev[1]
    prev = curr

print(sum(prev) % 9901)
