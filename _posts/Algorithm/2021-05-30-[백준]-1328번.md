---
date: 2021-05-30
title: "[백준]1328번"
categories: 알고리즘
tags: [백준,DP]
toc: true
toc_sticky: true 
---

# 고층 빌딩

문제
---
상근이가 살고있는 동네에는 빌딩 N개가 한 줄로 세워져 있다. 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 같은 높이를 가지는 빌딩은 없다. 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았다.

상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에, 빌딩이 어떤 순서로 위치해있는지는 알 수가 없다.

빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때, 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.

예를 들어, N = 5, L = 3, R = 2인 경우에 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다.

입력
---
첫째 줄에 빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어진다. (1 ≤ N ≤ 100, 1 ≤ L, R ≤ N)

출력
---
첫째 줄에 가능한 빌딩 순서의 경우의 수를 1000000007로 나눈 나머지를 출력한다.

예제 입력1
---
~~~
3 2 2
~~~

예제 출력 1
---
~~~
2
~~~

풀이
---
결론적으로 보면 점화식으로 풀어야 하는 문제였다. 테트리스를 하는것에서 힌트를 얻어 점화식을 작성했다. 

빌딩의 수가 N이고 왼쪽에서 본 빌딩수가 L, 오른쪽에서 본 빌딩수가 R을 만족하는 모든 집합을 $A_{NLR}$ 이라 하고 $A_{NLR}$의 모든 원소의 수를 $s_{NLR}$라 하자. 이 때 $s_{422}$를 구하는 과정을 예를 들어보자.

$a_{422}$를 구하는 과정은 크게 두가지 과정으로 나눠지는데 첫번째 과정이 아래 그림과 같은 경우이다.

![](/assets/images/1328(1).png)

테트리스 처럼 아래 한 개 층이 늘어난다고 생각해보자 그럼 $A_{312}$의 임의의 원소 $a_{312}$(왼쪽)에서 $a_{422}$(오른쪽)과 같은 방식으로 도형이 바뀌게 된다. 같은 방식으로 $a_{321}$ 또한 아래 그림과 같이 비슷한 방식으로 $A_{422}$ 의 원소를 구할 수 있다.

![](/assets/images/1328(2).png)

두번째 가정의 경우 아래 그림과 같은 과정을 거친다.

![](/assets/images/1328(3).png)

먼저 위와 같이 테트리스 처럼 한 줄을 추가해보자. 그럼 맨 왼쪽 또는 오른쪽에 높이 1 짜리 빌딩이 하나 추가 되므로 $a_{432}$ 가 만들어진다. 이를 $a_{422}$로 바꾸기 위해선 높이 1 짜리 빌딩을 빌딩 사이에 껴 넣으면 된다. 맨 끝만 제외하고 빌딩을 끼워넣으면 되므로 $N-2$의 경우의 수가 존재하게 된다.

최종적으로 정리하면 점화식은 아래와 같다.

$$s_{NLR} = s_{N-1L-1R} + s_{N-1LR-1} + s_{N-1LR} * (N - 2)$$

이 점화식을 그대로 DP를 통해 구현하면 된다. 

코드
---
~~~python
import sys

input_function = sys.stdin.readline
N, L, R = map(int, input_function().split(' '))

# init
dp = [[[0 for k in range(R+1)] for j in range(L+1)] for i in range(N+1)]

dp[1][1][1] = 1

for n in range(2, N+1):
    for l in range(1, L+1):
        for r in range(1, R+1):
            dp[n][l][r] = (dp[n - 1][l - 1][r] + dp[n - 1][l][r - 1] + dp[n - 1][l][r] * (n - 2)) % 1000000007

print(dp[N][L][R])
~~~
