# 백준 1753번

입력
---
첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.

출력
---
첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

'''python
import sys
import heapq


input_function = sys.stdin.readline
INF = sys.maxsize
V, E = [int(x) for x in input_function().split()]

K = int(input_function()) - 1
edge = [INF] * V
Q = []
graph = [[] for _ in range(V)]


def dijkstra(start):
    """
    1  function Dijkstra(Graph, source):
    2      dist[source] ← 0                                    // 초기화
    3
    4      create vertex set Q
    5
    6      for each vertex v in Graph:
    7          if v ≠ source
    8              dist[v] ← INFINITY                          // 소스에서 v까지의 아직 모르는 길이
    9          prev[v] ← UNDEFINED                             // v의 이전 노드
    10
    11         Q.add_with_priority(v, dist[v])
    12
    13
    14     while Q is not empty:                          // 메인 루프
    15         u ← Q.extract_min()                         // 최고의 꼭짓점을 제거하고 반환한다
    16         for each neighbor v of u:              // Q에 여전히 남아 있는 v에 대해서만
    17             alt ← dist[u] + length(u, v)
    18             if alt < dist[v]
    19                 dist[v] ← alt
    20                 prev[v] ← u
    21                 Q.decrease_priority(v, alt)
    22
    23     return dist, prev
    """
    edge[start] = 0
    heapq.heappush(Q, (0, start))
    while Q:
        w, vertex = heapq.heappop(Q)
        # if edge[vertex] < w:
        #     continue
        for next_w, next_vertex in graph[vertex]:
            updated_weight = next_w + w
            if updated_weight < edge[next_vertex]:
                edge[next_vertex] = updated_weight
                heapq.heappush(Q, (updated_weight, next_vertex))


# 초기화
for _ in range(E):
    u, v, w = [int(x) for x in input_function().split()]
    graph[u-1].append((w, v-1))

dijkstra(K)
for i in range(V):
    print("INF" if edge[i] == INF else edge[i])
'''
